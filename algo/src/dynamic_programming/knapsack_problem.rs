/// # Задача о рюкзаке (0/1 Knapsack Problem)
///
/// ## Формулировка задачи
/// У вас есть рюкзак с ограниченной вместимостью (capacity) и набор предметов.
/// Каждый предмет имеет вес (weight) и ценность (value).
/// Необходимо выбрать подмножество предметов, чтобы максимизировать суммарную ценность,
/// при этом суммарный вес не превышает вместимость рюкзака.
/// Каждый предмет можно взять только один раз (0/1 ограничение).
///
/// ## Пример
/// Предметы:
/// - Предмет 1: вес 1, ценность 10
/// - Предмет 2: вес 2, ценность 20
/// - Предмет 3: вес 3, ценность 30
/// - Предмет 4: вес 4, ценность 40
/// Вместимость рюкзака: 5
///
/// Оптимальное решение: предметы 2 и 3 (вес 2+3=5, ценность 20+30=50)
/// Альтернатива: предмет 4 (вес 4, ценность 40) - хуже
///
/// ## Подход с динамическим программированием
/// Используем таблицу DP, где dp[i][w] - максимальная ценность,
/// используя первые i предметов и вместимость w.
///
/// Переход:
/// - Если вес i-го предмета > w: dp[i][w] = dp[i-1][w]
/// - Иначе: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weight[i]] + value[i])
///
/// ## Варианты задачи
/// - Неограниченный рюкзак (Unbounded Knapsack): предметы можно брать несколько раз
/// - Рюкзак с дробными предметами (Fractional Knapsack): можно брать части предметов (жадный алгоритм)
///
/// Решение задачи о рюкзаке (0/1 Knapsack) с использованием динамического программирования.
///
/// # Аргументы
/// * `weights` - вектор весов предметов
/// * `values` - вектор ценностей предметов
/// * `capacity` - максимальная вместимость рюкзака
///
/// # Возвращает
/// Максимальную суммарную ценность предметов, которые можно уложить в рюкзак
///
/// # Временная сложность
/// O(n * capacity) — два вложенных цикла: внешний по n предметам, внутренний по capacity возможным весам (от 0 до capacity), каждый шаг выполняет константное количество операций.
///
/// # Пространственная сложность
/// O(n * capacity) — двумерная таблица dp размером (n+1) x (capacity+1), где хранятся промежуточные результаты для каждого подмножества предметов и каждой вместимости.
#[allow(dead_code)]
fn knapsack(weights: &[usize], values: &[usize], capacity: usize) -> usize {
    let n = weights.len();
    let mut dp = vec![vec![0; capacity + 1]; n + 1];

    for i in 1..=n {
        for w in 0..=capacity {
            if weights[i - 1] <= w {
                dp[i][w] = dp[i - 1][w].max(dp[i - 1][w - weights[i - 1]] + values[i - 1]);
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }

    dp[n][capacity]
}

/// # Оптимизированная версия с O(capacity) пространством
///
/// Использует только один массив dp[w], обновляя его в обратном порядке,
/// чтобы избежать использования одного и того же предмета несколько раз.
/// Это работает для 0/1 рюкзака, так как мы идем от большего веса к меньшему.
///
/// Для неограниченного рюкзака нужно идти от меньшего к большему.
///
/// # Временная сложность
/// O(n * capacity) — внешний цикл по n предметам, внутренний цикл от weights[i] до capacity (в среднем ~capacity операций на предмет, но зависит от веса).
///
/// # Пространственная сложность
/// O(capacity) — одномерный массив dp размером capacity+1, хранящий максимальные ценности для каждой вместимости.
#[allow(dead_code)]
fn knapsack_optimized(weights: &[usize], values: &[usize], capacity: usize) -> usize {
    let n = weights.len();
    let mut dp = vec![0; capacity + 1];

    for i in 0..n {
        for w in (weights[i]..=capacity).rev() {
            dp[w] = dp[w].max(dp[w - weights[i]] + values[i]);
        }
    }

    dp[capacity]
}

/// Тесты для функций решения задачи о рюкзаке
#[test]
fn test_knapsack_problem_dp() {
    // Пример 1: стандартный случай с несколькими предметами
    // Предметы: (вес, ценность) = (1,10), (2,20), (3,30), (4,40)
    // Вместимость: 5
    // Оптимально: предметы 2 и 3 (вес 5, ценность 50)
    let weights = vec![1, 2, 3, 4];
    let values = vec![10, 20, 30, 40];
    let capacity = 5;
    assert_eq!(knapsack(&weights, &values, capacity), 50);
    assert_eq!(knapsack_optimized(&weights, &values, capacity), 50);

    // Пример 2: один предмет, который помещается
    // Предмет: вес 2, ценность 10; вместимость 3
    let weights = vec![2];
    let values = vec![10];
    let capacity = 3;
    assert_eq!(knapsack(&weights, &values, capacity), 10);
    assert_eq!(knapsack_optimized(&weights, &values, capacity), 10);

    // Пример 3: предмет не помещается в рюкзак
    // Предмет: вес 5, ценность 10; вместимость 3
    let weights = vec![5];
    let values = vec![10];
    let capacity = 3;
    assert_eq!(knapsack(&weights, &values, capacity), 0);
    assert_eq!(knapsack_optimized(&weights, &values, capacity), 0);

    // Пример 4: нулевая вместимость рюкзака
    // Никакие предметы не могут быть выбраны
    let weights = vec![1, 2];
    let values = vec![10, 20];
    let capacity = 0;
    assert_eq!(knapsack(&weights, &values, capacity), 0);
    assert_eq!(knapsack_optimized(&weights, &values, capacity), 0);
}