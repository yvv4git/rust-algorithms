# C. Жадная доставка

**Статус:** Не решена

**Ограничение времени:** 4 секунды
**Ограничение памяти:** 256 Мб
**Ввод:** стандартный ввод или input.txt
**Вывод:** стандартный вывод или output.txt

Гамильтон купил франшизу интернет-магазина в удалённом регионе и сам развозит заказы на «буханке». Всего у него есть n пунктов выдачи, i-й из которых имеет координаты x_i, y_i. Дорог в регионе нет, поэтому движение от одного пункта выдачи до другого осуществляется по прямой. Чем дальше путь, который предстоит проехать на «буханке», тем больше грязи налипает и тем медленнее она едет. Гамильтон вывел правило: если расстояние между двумя пунктами выдачи равно d, то время проезда между ними равно d^2. При приезде к пункту выдачи Гамильтон моментально очищает грязь, таким образом, она не накапливается.

На одном из пунктов выдачи Гамильтон оборудует склад, куда заказы для всей его франшизы будут доставлять из логистического центра вертолетом. Заказов пока немного, поэтому товары для всех пунктов выдачи помещаются в «буханку» на складе. Когда Гамильтон развозит заказы, то, находясь в пункте выдачи с номером i, он выбирает ближайший пункт выдачи j, в котором он ещё не был, и едет в него. Если таких пунктов несколько, то он выберет пункт с наименьшим номером. Когда Гамильтон развезёт все заказы, то он остаётся в последнем посещённом пункте выдачи отдыхать.

Определите, в каком из пунктов выдачи нужно оборудовать склад, чтобы Гамильтон потратил как можно меньше времени на развоз заказов.

## Формат ввода
В первой строке вводится число n — число пунктов выдачи (2 ≤ n ≤ 300).

В следующих n строках вводятся координаты пунктов выдачи — целые числа x_i, y_i (-300 ≤ x_i, y_i ≤ 300).

## Формат вывода
Выведите минимальное время, за которое Гамильтон развезёт все заказы при оптимальном выборе места для склада.

## Система оценивания
Решения, верно работающие в случае n ≤ 100, будут получать не менее 55 баллов.

## Примеры

### Пример 1
**Ввод**
3
1 0
2 0
4 0

**Вывод**
5

### Пример 2
**Ввод**
4
0 1
1 0
0 0
1 1

**Вывод**
3

### Пример 3
**Ввод**
7
4 3
2 4
7 2
9 7
5 8
2 7
7 5

**Вывод**
51

## Примечания
Если в первом примере выбрать в качестве склада первый пункт выдачи, то сначала Гамильтон поедет во второй и потратит 1^2 = 1 времени, а затем поедет в третий и потратит 2^2 = 4 времени, в сумме 5.

Если выбрать в качестве склада второй пункт, то сначала Гамильтон поедет в первый и потратит 1^2 = 1 времени, а затем поедет в третий и потратит 3^2 = 9 времени, в сумме 10.

Если выбрать в качестве склада третий пункт, то сначала Гамильтон поедет во второй и потратит 2^2 = 4 времени, а затем поедет в первый и потратит 1^2 = 1 времени, в сумме 5.

Лучшее время — 5, можно выбрать 1 или 3 пункт (но его номер у нас не спрашивают).


## Solution
use std::io::{self, Read};

fn main() {
    // ---------- чтение ввода ----------
    let mut input = String::new();
    io::stdin().read_to_string(&mut input).unwrap();
    let mut it = input.split_whitespace();

    let n: usize = it.next().unwrap().parse().unwrap();
    let mut x = vec![0i64; n];
    let mut y = vec![0i64; n];

    for i in 0..n {
        x[i] = it.next().unwrap().parse().unwrap();
        y[i] = it.next().unwrap().parse().unwrap();
    }

    // ---------- предварительный расчёт квадратов расстояний ----------
    let mut dist = vec![vec![0i64; n]; n];
    for i in 0..n {
        for j in 0..n {
            let dx = x[i] - x[j];
            let dy = y[i] - y[j];
            dist[i][j] = dx*dx + dy*dy;
        }
    }

    // ---------- симуляция для всех возможных стартов ----------
    let mut best = i64::MAX;

    for start in 0..n {
        let mut used = vec![false; n];
        used[start] = true;
        let mut cur = start;
        let mut time_sum = 0i64;

        for _ in 1..n {
            let mut nxt = None;
            let mut best_d = i64::MAX;

            // ищем ближайший непосещённый
            for j in 0..n {
                if !used[j] {
                    let d = dist[cur][j];
                    if d < best_d || (d == best_d && Some(j) < nxt) {
                        best_d = d;
                        nxt = Some(j);
                    }
                }
            }

            let j = nxt.unwrap();
            used[j] = true;
            time_sum += best_d;
            cur = j;
        }

        if time_sum < best {
            best = time_sum;
        }
    }

    // ---------- вывод ----------
    println!("{}", best);
}
