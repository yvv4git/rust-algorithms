# B. Искусственная поэзия

**Статус:** Не решена

**Ограничение времени:** 1 секунда
**Ограничение памяти:** 256 Мб
**Ввод:** стандартный ввод или input.txt
**Вывод:** стандартный вывод или output.txt

Александр Сергеевич обучает большую языковую модель быть поэтом, но как он не бьется — у той не получается отличать ямб от хорея. Поэтому Александр Сергеевич решил измерять поэтичность математически, а там уж модель как-нибудь сама обучится на своих ошибках.

Пусть модель сгенерировала стих из n строк. В стихе должна быть периодичность. В соответствии с заданным поэтическим стилем суффиксы (окончания) строк, номера которых отличаются ровно на m, должны совпадать. Из всех строк, номера которых отличаются ровно на m, выбирается пара с самым коротким совпадающим суффиксом, и длина этого суффикса и определяет поэтичность всего стиха.

Определите поэтичность стиха.

## Формат ввода
В первой строке вводятся два числа n и m (1 ≤ m < n ≤ 1000) — количество строк в стихе и период, с которым они должны повторяться.

Далее идут n строк, содержащие только английские буквы и пробелы. Длина каждой строки не превосходит 1000 символов. Гарантируется, что строки не начинаются и не заканчиваются пробелом. Большие и маленькие буквы считаются различными.

## Формат вывода
Выведите одно число — поэтичность стиха.

## Система оценивания
Решения, верно работающие в случае, когда длина всех строк не превосходит 100, будут получать не менее 50 баллов.

## Примеры

### Пример 1
**Ввод**
4 2
oblepili lampu moshki
greyut tonenkie nozhki
ostorozhno Moshki
obozhzhete nozhki

**Вывод**
5

### Пример 2
**Ввод**
4 1
tam za uglom
prodayutsya reshetki stalnye
ikh dlya dvortsa svoego
pokupal shlemobleshchushchij Gektor

**Вывод**
0

## Примечания
В первом примере первая и третья строки (про мошек) имеют совпадающие суффиксы длины 5 (дальше следуют буквы m и M, которые считаются различными). Вторая и четвертая строки имеют совпадающие суффиксы длины 8 ("e nozhki"), но общая поэтичность определяется наименьшим суффиксом.



## Task2
use std::io::{self, Read};

fn main() {
    // Считываем весь ввод
    let mut input = String::new();
    io::stdin().read_to_string(&mut input).unwrap();
    let mut it = input.lines();

    // n, m
    let first = it.next().unwrap().split_whitespace().collect::<Vec<_>>();
    let n: usize = first[0].parse().unwrap();
    let m: usize = first[1].parse().unwrap();

    // строки
    let lines: Vec<String> = it.map(|s| s.to_string()).collect();

    let mut answer = usize::MAX;

    for i in 0..n - m {
        let a = lines[i].as_bytes();
        let b = lines[i + m].as_bytes();

        let mut cnt = 0;

        // сравниваем с конца
        let mut ia = a.len();
        let mut ib = b.len();

        while ia > 0 && ib > 0 {
            if a[ia - 1] == b[ib - 1] {
                cnt += 1;
                ia -= 1;
                ib -= 1;
            } else {
                break;
            }
        }

        if cnt < answer {
            answer = cnt;
        }
    }

    // Если не было ни одной пары (теоретически невозможно при 1 ≤ m < n)
    if answer == usize::MAX {
        answer = 0;
    }

    println!("{}", answer);
}
