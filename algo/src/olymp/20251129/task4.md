# D. Календарь комет

**Ограничение времени:** 1 секунда
**Ограничение памяти:** 256 Мб
**Ввод:** стандартный ввод или input.txt
**Вывод:** стандартный вывод или output.txt

В солнечной системе обращается k комет. Древние звездочёты в год номер 1 увидели на небе одновременно все k комет. Каждая из k комет имеет свой период обращения. Например, если комета имеет период обращения в 3 года, то она была видна в годы 1, 4, 7 и т.д. Звездочёты отметили в календаре все годы, когда на небе была хотя бы одна комета. В год X комета упала с неба на Землю, и после этого года записей звездочётов найдено не было.

По номерам годов, в которые звездочёты видели хотя бы одну комету, определите наименьшее возможное значение k.

## Формат ввода
В первой строке вводится число n (1 ≤ n ≤ 5000) — количество годов, в которые звездочёты видели на небе хотя бы одну комету.

Во второй строке вводятся номера годов, в которые на небе была хотя бы одна комета. Номера вводятся в возрастающем порядке. Первый номер всегда равен 1, а последний — X (1 ≤ X ≤ 10^9).

## Формат вывода
Выведите минимально возможное количество комет.

## Система оценивания
Решения, верно работающие при X ≤ 5000000, будут получать не менее 70 баллов.

## Примеры

### Пример 1
**Ввод**
3
1 3 4

**Вывод**
2

### Пример 2
**Ввод**
5
1 7 10 13 19

**Вывод**
2

### Пример 3
**Ввод**
3
1 500000000 999999999

**Вывод**
1



## Solution
use std::io::{self, Read};

fn main() {
    // Чтение входа
    let mut s = String::new();
    io::stdin().read_to_string(&mut s).unwrap();
    let mut it = s.split_whitespace();
    let n: usize = it.next().unwrap().parse().unwrap();
    let mut years: Vec<i64> = Vec::with_capacity(n);
    for _ in 0..n {
        years.push(it.next().unwrap().parse::<i64>().unwrap());
    }

    if n == 1 {
        // Только год 1 — достаточно одной кометы с периодом > 0 (например > X-1)
        println!("1");
        return;
    }

    // Сделаем массив b = years - 1, но исключим ноль (год 1 -> 0), т.к. мы работаем с положительными периодами
    let mut b: Vec<i64> = years.iter().map(|&y| y - 1).filter(|&x| x > 0).collect();
    // сортировать на всякий случай (вход уже возрастающий, но после вычитания 1 порядок сохраняется)
    b.sort_unstable();

    let m = b.len();
    let mut covered = vec![false; m];
    let mut ans = 0usize;

    for i in 0..m {
        if covered[i] {
            continue;
        }
        // Нужен новый период = b[i]
        let p = b[i];
        ans += 1;
        // Пометить все элементы, кратные p
        for j in i..m {
            if !covered[j] && b[j] % p == 0 {
                covered[j] = true;
            }
        }
    }

    println!("{}", ans);
}
