// Основная функция с тестовым примером
fn main() {
    let mut arr = [9, 3, 7, 4, 8, 1, 2, 6, 5];
    quicksort(&mut arr);
    println!("Отсортированный массив: {:?}", arr);
}

// Быстрая сортировка (quicksort)
// Временная сложность: O(n log n) в среднем случае, O(n²) в худшем случае
// Пространственная сложность: O(log n) из-за рекурсивных вызовов
fn quicksort(arr: &mut [i32]) {
    // Базовый случай: массивы длиной 0 или 1 уже отсортированы
    if arr.len() <= 1 { return; }

    // Разделение массива и получение индекса опорного элемента
    let pivot = partition(arr);
    // Разделение массива на две части относительно опорного элемента
    let (left, right) = arr.split_at_mut(pivot);
    // Рекурсивная сортировка левой и правой частей
    quicksort(left);
    quicksort(&mut right[1..]);
}

// Функция разделения массива (схема Ломуто)
// Возвращает индекс опорного элемента
fn partition(arr: &mut [i32]) -> usize {
    // Выбираем последний элемент в качестве опорного
    let pivot = arr.len() - 1;
    let mut i = 0; // Индекс для вставки меньших элементов
    
    // Проходим по всем элементам кроме опорного
    for j in 0..pivot {
        // Если текущий элемент меньше опорного
        if arr[j] < arr[pivot] {
            // Переставляем его в часть для меньших элементов
            arr.swap(i, j);
            i += 1;
        }
    }
    // Ставим опорный элемент на правильную позицию
    arr.swap(i, pivot);
    i // Возвращаем индекс опорного элемента
}