// Задача "Ханойские башни" - классическая головоломка, где нужно переместить башню из дисков
// с одного стержня на другой, соблюдая правила:
// 1. За один ход можно перемещать только один диск
// 2. Нельзя класть больший диск на меньший
// 3. Используется третий вспомогательный стержень для временного хранения дисков
// Решение реализовано рекурсивно


// Рекурсивное решение основано на следующем принципе:
// Чтобы переместить $ n $ дисков с A на C, используя B:
// 1. Переместите $ n-1 $ верхних дисков с A на B, используя C как промежуточный стержень.
// 2. Переместите самый большой диск (n-й) с A на C.
// 3. Переместите $ n-1 $ дисков с B на C, используя A как промежуточный стержень.

fn main() {
    // Пример использования функции
    let n = 3; // Количество дисков
    tower_of_hanoi(n, "A", "C", "B");
}

// Решение задачи "Ханойские башни"
// 
// # Аргументы
// * `n` - количество дисков для перемещения
// * `source` - имя исходного стержня
// * `destination` - имя целевого стержня
// * `auxiliary` - имя вспомогательного стержня
fn tower_of_hanoi(n: i32, source: &str, destination: &str, auxiliary: &str) {
    // Базовый случай: если остался только один диск
    if n == 1 {
        println!("Переместить диск 1 со стержня {} на стержень {}", source, destination);
        return;
    }

    // Рекурсивно перемещаем n-1 дисков с исходного на вспомогательный стержень,
    // используя целевой стержень как вспомогательный
    tower_of_hanoi(n - 1, source, auxiliary, destination);

    // Перемещаем оставшийся диск (самый большой) на целевой стержень
    println!("Переместить диск {} со стержня {} на стержень {}", n, source, destination);

    // Рекурсивно перемещаем n-1 дисков с вспомогательного на целевой стержень,
    // используя исходный стержень как вспомогательный
    tower_of_hanoi(n - 1, auxiliary, destination, source);
}
