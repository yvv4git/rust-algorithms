/// Генерация всех перестановок элементов вектора.
///
/// Перестановка - это упорядоченное расположение элементов множества.
/// Для множества из n элементов существует n! (n факториал) различных перестановок.
/// Эта функция рекурсивно генерирует все возможные перестановки путем обмена элементов.
/// Перестановки используются в задачах, где важен порядок всех элементов множества,
/// например, при генерации всех возможных упорядочений объектов, в алгоритмах
/// полного перебора для небольших множеств, или в криптографии для генерации ключей.
///
/// # Аргументы
/// * `items` - Срез элементов, для которых нужно сгенерировать перестановки.
///   Элементы должны реализовывать трейт Clone для копирования.
///
/// # Возвращает
/// Вектор векторов, где каждый внутренний вектор - одна перестановка.
///
/// # Примеры
/// ```
/// let perms = permutations(&[1, 2, 3]);
/// // perms будет содержать все 6 перестановок: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]
/// ```
#[allow(dead_code)]
fn permutations<T: Clone>(items: &[T]) -> Vec<Vec<T>> {
    let mut result = Vec::new();
    let mut items = items.to_vec();
    generate_permutations(&mut items, 0, &mut result);
    result
}

/// Вспомогательная рекурсивная функция для генерации перестановок.
///
/// Использует алгоритм Heap's algorithm для генерации перестановок.
/// На каждом шаге фиксирует элемент на позиции start и рекурсивно
/// генерирует перестановки для оставшихся элементов.
///
/// # Аргументы
/// * `items` - Изменяемый вектор элементов
/// * `start` - Индекс, с которого начинаем генерацию
/// * `result` - Вектор для сбора результатов
#[allow(dead_code)]
fn generate_permutations<T: Clone>(items: &mut [T], start: usize, result: &mut Vec<Vec<T>>) {
    if start == items.len() {
        result.push(items.to_vec());
        return;
    }

    for i in start..items.len() {
        // Обмен элементов
        items.swap(start, i);
        // Рекурсивный вызов для следующей позиции
        generate_permutations(items, start + 1, result);
        // Возврат к исходному порядку (backtrack)
        items.swap(start, i);
    }
}

#[test]
fn test_permutation() {
    // Тест для пустого вектора
    let empty: Vec<i32> = vec![];
    assert_eq!(permutations(&empty), vec![vec![]]);

    // Тест для одного элемента
    assert_eq!(permutations(&[1]), vec![vec![1]]);

    // Тест для двух элементов
    let mut perms_2 = permutations(&[1, 2]);
    perms_2.sort(); // Сортируем для детерминированного порядка в тесте
    assert_eq!(perms_2, vec![vec![1, 2], vec![2, 1]]);

    // Тест для трех элементов
    let mut perms_3 = permutations(&[1, 2, 3]);
    perms_3.sort();
    let expected = vec![
        vec![1, 2, 3], vec![1, 3, 2], vec![2, 1, 3],
        vec![2, 3, 1], vec![3, 1, 2], vec![3, 2, 1]
    ];
    assert_eq!(perms_3, expected);
}