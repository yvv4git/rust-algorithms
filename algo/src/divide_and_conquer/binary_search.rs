// Бинарный поиск - алгоритм поиска элемента в отсортированном массиве
// Временная сложность: O(log n)
// Пространственная сложность: O(1)
//
// Алгоритм:
// 1. Проверяем, что массив не пустой
// 2. Устанавливаем границы поиска (low и high)
// 3. Пока границы не сойдутся:
//    - Находим середину
//    - Сравниваем элемент с искомым значением
//    - Сдвигаем границы в зависимости от сравнения
// 4. Проверяем последний оставшийся элемент

fn main() {
    // Пример использования
    let arr = [1, 3, 5, 7, 9];
    println!("{:?}", binary_search(&arr, 3)); // Some(1)
    println!("{:?}", binary_search(&arr, -1)); // None
}

/// Функция бинарного поиска в отсортированном массиве
///
/// # Аргументы
/// * `arr` - срез отсортированного массива для поиска
/// * `target` - искомое значение
///
/// # Возвращаемое значение
/// `Some(usize)` с индексом элемента, если найден
/// `None`, если элемент не найден или массив пустой
fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    // Проверка на пустой массив
    if arr.is_empty() {
        return None;
    }
    
    // Установка начальных границ
    let mut low = 0;
    let mut high = arr.len() - 1;

    // Основной цикл поиска
    while low < high {
        // Вычисление середины без переполнения
        let mid = low + (high - low) / 2;
        
        // Сравнение элемента с искомым значением
        match arr[mid].cmp(&target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => low = mid + 1, // Ищем в правой части
            std::cmp::Ordering::Greater => high = mid, // Ищем в левой части
        }
    }

    // Проверка последнего оставшегося элемента
    if arr[low] == target {
        Some(low)
    } else {
        None
    }
}