/*
У тебя есть вектор чисел, и нужно вернуть индексы двух элементов, 
сумма которых равна заданному числу target.  
Но - нельзя использовать вложенные циклы (O(n^2)). Сделай решение за O(n).

Подсказка:
- Подумай про использование HashMap:
- сохраняй уже просмотренные числа и их индексы
- при просмотре нового элемента проверяй, есть ли в HashMap нужное дополнение (target - num)

Так можно пройтись по массиву один раз и сразу найти ответ.
*/
use std::collections::HashMap;

fn main() {
    // Исходные данные: вектор чисел и целевая сумма
    // Time complexity: O(n) - проходим по массиву один раз
    // Space complexity: O(n) - в худшем случае сохраняем все элементы
    let nums = vec![2, 7, 11, 15];
    let target = 9;
    
    // Хэш-мапа для хранения чисел и их индексов
    let mut seen = HashMap::new();
    
    // Проходим по всем числам вектора
    for (i, &num) in nums.iter().enumerate() {
        // Вычисляем дополнение (число, которое в сумме с текущим даст target)
        let complement = target - num;
        
        // Проверяем, есть ли дополнение в хэш-мапе
        if seen.contains_key(&complement) {
            // Если есть - выводим индексы и завершаем программу
            println!("Indices: [{}, {}]", seen[&complement], i);
            return;
        }
        
        // Добавляем текущее число и его индекс в хэш-мапу
        seen.insert(num, i);
    }
    
    // Если решение не найдено
    println!("No two sum solution found!");
}